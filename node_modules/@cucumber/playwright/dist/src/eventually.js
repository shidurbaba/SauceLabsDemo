"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Waits for a condition to eventually pass. The condition may run several times depending on the timeout
 * and interval values of options.
 *
 * @param condition
 * @param options
 */
function eventually(condition, options) {
    const { interval, timeout } = Object.assign({ interval: 50, timeout: 1000 }, options);
    let lastError = undefined;
    let intervalId;
    let timeoutId;
    const conditionPromise = new Promise((resolve) => {
        intervalId = setIntervalImmediately(() => {
            try {
                // If condition() does not return a Promise, this will convert it into one
                // If condition() returns a Promise, this will just return the same promise
                Promise.resolve(condition())
                    .then((result) => resolve(result))
                    .catch((err) => (lastError = err));
            }
            catch (err) {
                // condition() threw an error (it was synchronous, not returning a Promise)
                lastError = err;
            }
        }, interval);
    });
    const timeoutPromise = new Promise((resolve, reject) => (timeoutId = setTimeout(() => {
        reject(lastError || new Error(`Timeout after ${timeout}ms`));
    }, timeout)));
    return new Promise((resolve, reject) => {
        Promise.race([conditionPromise, timeoutPromise])
            .then((result) => {
            clearInterval(intervalId);
            clearTimeout(timeoutId);
            resolve(result);
        })
            .catch((err) => {
            clearInterval(intervalId);
            clearTimeout(timeoutId);
            reject(err);
        });
    });
}
exports.default = eventually;
// setInterval does not invoke the function immediately, but waits for the first interval.
// This function makes sure it is called immediately.
function setIntervalImmediately(callback, ms) {
    const iv = setInterval(callback, ms);
    callback();
    return iv;
}
